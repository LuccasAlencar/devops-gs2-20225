# Azure Pipeline YAML para DEVOPS TOOLS & CLOUD COMPUTING - GS2 2025
# Build e Release automático para aplicação .NET 8
# Region: Canada Central

trigger:
  branches:
    include:
    - main
  paths:
    exclude:
    - README.md
    - tarefas.txt

pr:
  branches:
    include:
    - main

variables:
  # Configurações do projeto
  buildConfiguration: 'Release'
  project: 'dotnet-gs2-2025.csproj'
  dockerfilePath: '$(Build.SourcesDirectory)/dockerfiles/Dockerfile'
  location: 'canadacentral'
  
  # Configurações Azure (devem ser configuradas no Variable Group)
  azureSubscription: 'AzureSubscription'
  resourceGroupName: 'rg-devops-gs2-2025'
  containerRegistry: 'acrdevopsgs22025.azurecr.io'
  containerName: 'aci-devops-gs2-2025'
  imageName: 'devops-gs2-2025:$(Build.BuildId)'

stages:
- stage: Build
  displayName: 'Build Stage'
  jobs:
  - job: Build
    displayName: 'Build Application'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: UseDotNet@2
      displayName: 'Install .NET 8 SDK'
      inputs:
        packageType: 'sdk'
        version: '8.x'
    
    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet Packages'
      inputs:
        command: 'restore'
        projects: '$(project)'
    
    - task: DotNetCoreCLI@2
      displayName: 'Build Application'
      inputs:
        command: 'build'
        projects: '$(project)'
        arguments: '--configuration $(buildConfiguration) --no-restore'
    
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: 'test'
        projects: '**/*Tests.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --no-restore --collect:"XPlat Code Coverage" --logger trx'
        publishTestResults: true
    
    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Code Coverage'
      inputs:
        summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
        codecoverageTool: 'Cobertura'
    
    - task: DotNetCoreCLI@2
      displayName: 'Publish Application'
      inputs:
        command: 'publish'
        projects: '$(project)'
        arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory) --no-build'
        zipAfterPublish: false
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Artifacts'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'
        publishLocation: 'Container'

- stage: BuildAndPushDocker
  displayName: 'Docker Build and Push'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: Docker
    displayName: 'Build and Push Docker Image'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Build Artifacts'
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: 'drop'
        downloadPath: '$(System.ArtifactsDirectory)'
    
    - task: Docker@2
      displayName: 'Build Docker Image'
      inputs:
        containerRegistry: '$(azureSubscription)'
        repository: '$(containerRegistry)/$(imageName)'
        command: 'build'
        Dockerfile: '$(dockerfilePath)'
        buildContext: '$(System.ArtifactsDirectory)/drop'
        tags: |
          $(Build.BuildId)
          latest
    
    - task: Docker@2
      displayName: 'Push Docker Image'
      inputs:
        containerRegistry: '$(azureSubscription)'
        repository: '$(containerRegistry)/$(imageName)'
        command: 'push'
        tags: |
          $(Build.BuildId)
          latest

- stage: Deploy
  displayName: 'Release Stage'
  dependsOn: BuildAndPushDocker
  condition: succeeded()
  jobs:
  - deployment: DeployToAzure
    displayName: 'Deploy to Azure Container Instance'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            displayName: 'Deploy to Azure Container Instance'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Configurações do ACI
                RESOURCE_GROUP="$(resourceGroupName)"
                CONTAINER_NAME="$(containerName)"
                IMAGE_NAME="$(containerRegistry)/$(imageName):$(Build.BuildId)"
                
                # Verificar se o container já existe e deletar antes de criar
                if az container show --resource-group $RESOURCE_GROUP --name $CONTAINER_NAME --output none 2>/dev/null; then
                  echo "Container exists, deleting and recreating..."
                  az container delete \
                    --resource-group $RESOURCE_GROUP \
                    --name $CONTAINER_NAME \
                    --yes
                else
                  echo "Creating new container..."
                fi
                
                # Criar container com nova imagem
                az container create \
                  --resource-group $RESOURCE_GROUP \
                  --name $CONTAINER_NAME \
                  --image $IMAGE_NAME \
                  --cpu 1 \
                  --memory 2 \
                  --ports 8080 \
                  --dns-name-label $CONTAINER_NAME \
                  --restart-policy Always \
                  --environment-variables \
                    ASPNETCORE_ENVIRONMENT=Production \
                    ASPNETCORE_URLS=http://+:8080
                
                # Obter URL do container
                echo "Container deployed successfully!"
                echo "URL: http://$(az container show --resource-group $RESOURCE_GROUP --name $CONTAINER_NAME --query ipAddress.fqdn --output tsv):8080"

- stage: DatabaseSetup
  displayName: 'Database Setup'
  dependsOn: Deploy
  condition: succeeded()
  jobs:
  - job: SetupDatabase
    displayName: 'Setup MySQL Database'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: AzureCLI@2
      displayName: 'Execute Database Script'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Configurações do MySQL Container Instance
          RESOURCE_GROUP="$(resourceGroupName)"
          MYSQL_CONTAINER="aci-mysql-server"
          MYSQL_DATABASE="devops_gs2_2025"
          MYSQL_USER="devopsadmin"
          MYSQL_PASSWORD="DevOps@2025!GS2"
          
          # Esperar MySQL estar pronto
          echo "Waiting for MySQL to be ready..."
          sleep 30
          
          # Converter script SQL para base64 e executar
          SCRIPT_B64=$(base64 -w 0 < "$(Build.SourcesDirectory)/scripts/script-bd.sql")
          
          # Executar script no container MySQL
          az container exec \
            --resource-group $RESOURCE_GROUP \
            --name $MYSQL_CONTAINER \
            --exec-command "bash -c 'echo $SCRIPT_B64 | base64 -d | mysql -u root -pDevOps@2025!GS2'"
          
          echo "Database setup completed successfully!"
